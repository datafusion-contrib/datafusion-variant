# tests the variant_schema udf 
# this function takes a VARIANT expression
# and extracts each row's SQL schema

# simple example with a scalar value
query T
SELECT variant_schema(json_to_variant('{"key": 123, "data": [4, 5]}'))
----
OBJECT<data: ARRAY<Int8>, key: Int8>

# column input (row-wise, non-aggregate)
statement ok
CREATE TABLE t_col AS VALUES
(json_to_variant('{"a": 1}')),
(json_to_variant('[1, 2, 3]'));

query T
SELECT variant_schema(column1) FROM t_col ORDER BY 1;
----
ARRAY<Int8>
OBJECT<a: Int8>


# conflicting element types in array
query T
SELECT variant_schema(json_to_variant('{"data": [{"a":"a"}, 5]}'))
----
OBJECT<data: ARRAY<VARIANT>>

# typed literal
query T 
SELECT variant_schema(json_to_variant(123.4))
----
Float64

# explicit null
query T
SELECT variant_schema(json_to_variant('null'))
----
Null

# json null
query T
SELECT variant_schema(json_to_variant('{"a": null}'))
----
OBJECT<a: Null>

# numeric widening
query T
SELECT variant_schema(json_to_variant('[1, 2.5, 3]'))
----
ARRAY<Float64>

# array of objects
query T
SELECT variant_schema(json_to_variant('[{"a":1},{"a":2}]'))
----
ARRAY<OBJECT<a: Int8>>

# empty object
query T
SELECT variant_schema(json_to_variant('{}'))
----
OBJECT<>

# empty array
query T
SELECT variant_schema(json_to_variant('[]'))
----
ARRAY<Null>

# field ordering
query T
SELECT variant_schema(json_to_variant('{"b":1,"a":2}'))
----
OBJECT<a: Int8, b: Int8>

# last key wins?
query T
SELECT variant_schema(json_to_variant('{"a": 1, "a": {"b":2}}'))
----
OBJECT<a: OBJECT<b: Int8>>
